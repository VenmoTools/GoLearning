# 内存简介
## 物理地址与虚拟地址
计算机的主存储器被组织成一个有M个连续的字节大小的单元组成的数组，每个字节都有唯一一个物理地址(Physical Address)，第一个字节的地址为0，下一个字节地址为1... CPU访问内存的最自然的方式就是使用物理地址称为`物理寻址`，早期的PC使用物理寻址，现代处理器使用的是`虚拟寻址(Virtual Addressing)`的方式,如图：

<img src="note/memory/img/虚拟寻址.png">

通过虚拟寻址，CPU通过生成一个虚拟地址来访问主存储器，这个虚拟地址在被送到内存之前先转换成适当的物理地址，将一个虚拟地址转为物理地址称为地址翻译(Address Translation) CPU使用CPU芯片上的内存管理单元(Memory Mangement Uint,MMU)将存放在主存储器中的查询表来动态翻译虚拟地址

虚拟内存被组织为一个有存放在磁盘上的N个连续字节大小的单元形成的数组，每个字节都有唯一一个虚拟地址，作为数组的索引，磁盘上数组的内容台北缓存到主存储器中，虚拟内存系统将虚拟内存分割为虚拟页(Virtual Page)的大小固定的块来处理，物理内存被分割为物理页(Phyiscal Page)

虚拟页面的分为三种

+ 未分配的：虚拟内存系统还未分配（未创建）的页，为分配的块没有任何数据关联，不占用任何磁盘空间
+ 缓存的：当前已缓存在物理内存的已分配的页
+ 未缓存的：未缓存在物理内存中的已分配的页


## 组织结构

位于CPU和主存储器之间的L1，L2，L3高速缓存称为SRAM，将虚拟内存系统的缓存和主存储器中的缓存虚拟页称为DRAM

DRAM比SRAM慢10倍，磁盘比DRAM满大约100 000倍，因此DRAM缓存的不命中(找到相应的地址)比SRAM不命中代价要昂贵的多，因为DRAM不命中需要有磁盘来服务，SRAM不命中通常是基于DRAM的主存储器来服务的DRAM的组织结构是一个巨大的不命中开销驱动的

虚拟页在大的不命中的处罚和访问第一个字节的开销很大，通常是4KB～2MB，操作系统对DRAM使用了替换算法，因为对磁盘的长时间访问，DRAM使用写回而不是直写

## 页表

虚拟内存系统必须有某种方法来判定一个虚拟页是否在DRAM中，如果存在需要确定这个虚拟页存放在那个物理页中，如果不命中，徐彤必须判断这个虚拟页存放在磁盘的哪个位置，物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页

页表将虚拟页映射到物理页，每次地址翻译将一个虚拟地址转为物理地址时都会读取页表，操作系统负责维护页表内容，以及在磁盘与DRAM之间来回传送页

页表就是一个页表条目(Page Table Entry,PTE)的数组，虚拟地址空间中的每个页在页表中一个固定偏移处都会有一个PTE，假设每个PTE有一个有效位和一个n位地址组成的，有效位表明了当前虚拟页是否被缓存在DRAM中，如果设置了有效位，那么地址表示DRAM中的相应物理页的起始地址，否则这个地址就指向该虚拟页在磁盘上的起始位置。

<img src="note/memory/img/页表.png">

## 页命中

当CPU想要读取保存的VP2中的虚拟内存的一个字节时，地址翻译硬件将虚拟地址作为一个索引来定位PTE2并从内存读取它，因为设置了有效位，那么地址翻译硬件就知道VP2是缓存在内存中的，所以它使用PTE中的物理内存地址构造出这个字的物理地址

## 残页

DRAM缓存不命中称为缺页

CPU引用了VP3中的一个字，CPU3并未缓存在DRAM中，地址翻译硬件从内存读取PTE3 从有效位推断出VP3未被缓存，并处罚一个缺页异常，缺页异常调用内存中的缺页异常处理程序，该程序会选择一个牺牲页，例如存放在PP3中的VP4，VP4已经被修改，那么内核就会将它复制回磁盘，无论那种情况，内存都会修改VP4的页表条目，反映出VP4不在缓存在主存中中的一事实

<img src="note/memory/img/VM页命中.png">

<i>缺页之前</i>

然后内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回，当异常处理程序返回时，它重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件，VP3已经缓存在主内存中的，那么页命中也能由地址翻译硬件正常处理，


<img src="note/memory/img/缺页之后.png">

<i>缺页之后</i>



